import time
import datetime
from datetime import timedelta
import pandas as pd
import numpy as np
from dateutil.parser import parse

# TODO Pandas窗口计算
"""
Pandas提供几种窗口函数，如移动窗口函数rolling()、扩展窗口函数expanding()和指数加权移动ewm()，
同时可在此基础上调用适合的统计函数，如求和、中位数、均值、协方差、方差、相关性等。

所谓窗口，就是在一个数列中，选择一部分数据所形成的一个数据区间。
按照一定的规则产生很多窗口，对每个窗口施加计算得到的结果集成为一个新的数列，这个过程就是窗口计算。
可以把“窗口”（windows）这个概念理解为集合，一个窗口就是一个集合。
在统计分析中需要不同的“窗口”，比如一个部门分成不同组，在统计时会按组进行平均、排名等操作。
再比如，对于时间这种有顺序的数据，我们可能5天或者一个月分一组再进行排序、求中位数等计算。

移动窗口:移动窗口rolling()与groupby很像，但并没有固定的分组，而是创建了一个按一定移动位（如10天）移动的移动窗口对象。
       我们再对每个对象进行统计操作。一个数据会参与到多个窗口（集合、分组）中，而groupby中的一个值只能在一个组中。
       原数据按照固定大小的窗口依次移动，直至全部覆盖数据。

扩展窗口:“扩展”（expanding）是从数据（大多情况下是时间）的起始处开始窗口，增加窗口直到指定的大小。
       一般所有的数据都会参与所有窗口。
       它设置一个最小起始窗口，然后逐个向后扩展，实现类似累加的效果。

指数加权移动:在上述两个统计方法中，分组中的所有数值的权重都是一样的，
           而指数加权移动（exponential weighted moving）对分组中的数据给予不同的权重，用于后面的计算中。
           机器学习中的重要算法梯度下降法就是计算了梯度的指数加权平均数，并以此来更新权重，这种方法的运行速度几乎总是快于标准的梯度下降算法。

s.rolling()是移动窗口函数，此函数可以应用于一系列数据，指定参数window=n，并在其上调用适合的统计函数。
"""
# s = pd.Series(range(1, 7))
# print(s)
"""
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
"""
# print(s.rolling(2))
"""
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64
Rolling [window=2,center=False,axis=0,method=single]
"""
# TODO 2.1移动窗口
# print(s.rolling(2).sum())
"""
0     NaN
1     3.0
2     5.0
3     7.0
4     9.0
5    11.0
dtype: float64

第一个窗口（索引0）由于只有一个元素，不满足窗口大小，所以窗口求和无法进行，结果为NaN。
第二个窗口（索引0、1）里的值为1和2，窗口求和值为3，依次推得所有窗口的求和值，
形成了一个与原数据形状一样的新数据。这就是移动窗口的计算过程。
"""

"""
df.rolling(window, 
           min_periods=None, 
           center=False, 
           win_type=None, 
           on=None, 
           axis=0, 
           closed=None)
window：必传，如果使用int，可以表示窗口的大小；如果是offset类型，表示时间数据中窗口按此时间偏移量设定大小。
min_periods：每个窗口的最小数据，小于此值窗口的输出值为NaN，offset情况下，默认为1。默认情况下此值取窗口的大小。
win_type：窗口的类型，默认为加权平均，支持非常丰富的窗口函数，
如boxcar、triang、blackman、hamming、bartlett、parzen、bohman、blackmanharris、nuttall、barthann、kaiser(beta)、
gaussian(std)、general_gaussian (power, width)、slepian (width)、exponential (tau)等。
具体算法可参考SciPy库的官方文档：https://docs.scipy.org/doc/scipy/reference/signal.windows.html。
on：可选参数，对于DataFrame要作为窗口的列。
axis：计算的轴方向。
closed：窗口的开闭区间定义，支持'right'、'left、'both'或'neither'。对于offset类型，默认是左开右闭，默认为right。
"""

# 移动窗口使用
# df = pd.DataFrame(np.random.randn(30, 4),
#                   index=pd.date_range('2025-01-01', periods=30),
#                   columns=['A', 'B', 'C', 'D'])
# print(df)
"""
                   A         B         C         D
2025-01-01  1.415981  0.712992  1.004190 -0.276733
2025-01-02 -0.757962  0.808382 -1.057823  0.395040
2025-01-03 -1.584397  1.571269  1.918627  0.275410
...
2025-01-30 -0.740402  0.635338 -0.617755  0.666044
"""
# 每两天一个窗口，求平均数
# print(df.rolling(2).mean())
# print(df.rolling(2).sum())

"""
                   A         B         C         D
2025-01-01       NaN       NaN       NaN       NaN
2025-01-02  1.296557  0.196198 -0.105164  0.001027
2025-01-03 -0.222668 -0.407582  0.601515  0.993150
...
2025-01-29 -0.429574 -0.416686 -0.269382 -1.132408
2025-01-30 -0.823855  0.740831 -0.452809 -0.814366

                   A         B         C         D
2025-01-01       NaN       NaN       NaN       NaN
2025-01-02  2.593115  0.392396 -0.210328  0.002054
2025-01-03 -0.445337 -0.815164  1.203029  1.986301
...
2025-01-29 -0.859148 -0.833372 -0.538764 -2.264817
2025-01-30 -1.647710  1.481662 -0.905619 -1.628733
"""
# 我们使用时间偏移作为周期，2D代表两天，与上例相同，
# 不过，使用时间偏移的话，默认的最小观察数据为1，所以第一天也是有数据的，即它自身：
# print(df.rolling('2D').mean())
"""
                   A         B         C         D
2025-01-01  0.067133  0.059717 -0.224679  0.077064
2025-01-02 -0.081840 -0.012476  0.047198 -0.731008
...
2025-01-29 -1.619030 -0.954643  0.179781  0.114655
2025-01-30 -0.765650 -0.250299  0.133395 -0.855832
"""

# 如果只对一指定列进行窗口计算，可用以下两个方法之一
# print(df.rolling('2D')['A'].mean())
# print(df.A.rolling('2D').mean())

"""
2025-01-01    0.590088
2025-01-02    0.071717
...
2025-01-29    1.203945
2025-01-30   -0.231696
Freq: D, Name: A, dtype: float64
"""

# 使用窗口函数时可以指定窗口类型，如汉明（Hamming）窗
# print(df.rolling(2, win_type='hamming').sum())

"""
窗口主要支持以下统计方法。
    count()：非空值数
    sum()：值的总和
    mean()：平均值
    median()：数值的算术中位数
    min()：最小值
    max()：最大值
    std()：贝塞尔校正的样本标准偏差
    var()：无偏方差
    skew()：样本偏斜度（三阶矩）
    kurt()：峰度样本（四阶矩）
    quantile()：样本分位数（百分位上的值）
    cov()：无偏协方差（二进制）
    corr()：关联（二进制）
"""
# 对同一列使用多个函数，同时对不同函数计算出的列命名
# print(df.A.rolling('2D').agg({'A_sum': sum, 'A_std': np.std}))
"""
               A_sum     A_std
2025-01-01  1.442452       NaN
2025-01-02  2.414148  0.332875
2025-01-03  1.544276  0.282218
"""

# TODO 2.2扩展窗口
"""
expanding()是Pandas扩展窗口的实现函数，在使用和功能上简单很多，使用逻辑与rolling()一样。
rolling()窗口大小固定，移动计算，而expanding()只设最小可计算数量，不固定窗口大小，不断扩展进行计算.
"""
# s = pd.Series(range(1, 7))
# print(s)
# print(s.expanding(2).sum())
"""
0    1
1    2
2    3
3    4
4    5
5    6
dtype: int64

0     NaN
1     3.0
2     6.0
3    10.0
4    15.0
5    21.0
dtype: float64

expanding()的窗口每一步都在延伸：在第一个元素时，由于限定窗口为2，所以无法计算，结果是NaN；
到第二个元素时，窗口内有1和2，算出结果为3；在第三个元素时窗口内已经包含了1、2、3或者说 3、3，计算得6；依次类推，直至全部计算完毕。
实际上，当rolling()函数的窗口大小参数window为len(df)时，最终效果与expanding()是一样的。

移动窗口函数rolling()和扩展窗口函数expanding()十分类似，不同点仅限于窗口大小是否固定。
rolling()更为常用，它提供了更为丰富的参数，可以指定非常多的窗口函数来实现复杂的计算。
"""



